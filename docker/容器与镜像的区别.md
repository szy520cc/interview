# 容器与镜像的区别

镜像是静态的，容器是动态的。这是面试中最经典的回答，但需要进一步解释其深层含义。

### 核心区别

| 特性     | 镜像 (Image)                                       | 容器 (Container)                                     |
| :------- | :------------------------------------------------- | :--------------------------------------------------- |
| **本质**   | 一个**只读**的模板，包含了运行应用所需的文件系统和配置。 | 镜像的一个**可运行实例**。                             |
| **状态**   | **静态的 (Static)**，一旦创建就不会改变。              | **动态的 (Dynamic)**，有自己的生命周期（创建、运行、停止、删除）。 |
| **层级**   | 由多个只读层（layers）堆叠而成。                     | 在镜像的只读层之上，增加一个**可写的容器层**。         |
| **类比**   | 面向对象编程中的**类 (Class)**。                    | 类的**实例 (Instance/Object)**。                      |
| **持久化** | 镜像是持久化的，存储在 Docker 仓库或本地。           | 容器默认是临时的，删除后所有改动都会丢失（除非使用数据卷）。 |

### 详细解释

1.  **镜像 (Image)**
    -   **构建块**: 镜像是构建容器的基础。它像一个打包好的软件包，包含了应用程序代码、运行时库、环境变量和配置文件。
    -   **分层结构**: Docker 镜像采用分层存储（Union File System）。每一条 Dockerfile 指令（如 `RUN`, `COPY`）都会创建一个新的层。这种设计使得镜像构建和分发更高效，因为不同的镜像可以共享相同的层。
    -   **不可变性**: 镜像是只读的。一旦构建完成，其内容就不会再改变。如果需要更新，需要创建一个新的镜像。

2.  **容器 (Container)**
    -   **运行环境**: 容器是基于镜像启动的，为应用程序提供了一个隔离的、轻量级的运行环境。
    -   **可写层**: 当一个容器从镜像启动时，Docker 会在镜像的只读层之上添加一个可写的“容器层”。所有对容器文件系统的修改（如创建、修改、删除文件）都发生在这个可写层中。
    -   **隔离性**: 每个容器都拥有自己独立的文件系统、网络栈、进程空间。这种隔离性由 Linux 的命名空间（Namespaces）和控制组（Cgroups）技术保证。
    -   **生命周期**: 容器可以被创建 (`docker run`)、启动 (`docker start`)、停止 (`docker stop`)、删除 (`docker rm`)。它的状态是动态变化的。

### 总结

-   **镜像**是蓝图，定义了“什么”被包含在内。
-   **容器**是实现，是蓝图的一个活生生的、正在运行的副本。

你可以用一个镜像启动多个容器，这些容器共享相同的只读镜像层，但每个容器都有自己独立的可写层，因此它们之间互不影响。
