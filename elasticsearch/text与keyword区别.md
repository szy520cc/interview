以下是 **Elasticsearch 中 `text` 和 `keyword` 数据类型的详细对比**，结合补充内容整理而成，涵盖原理、使用场景及 PHP 示例：

---

### **一、核心区别总结**

| **特性**               | **text**                                                                 | **keyword**                                                                 |
|------------------------|--------------------------------------------------------------------------|-----------------------------------------------------------------------------|
| **分词行为**           | **会分词**（如英文按空格切分，中文按字符/分词器切分）。                   | **不分词**（原样存储和查询）。                                             |
| **索引方式**           | 倒排索引（支持全文搜索、模糊匹配）。                                     | 精确索引（支持等值查询、排序、聚合）。                                     |
| **查询方式**           | 使用 `match` `match_phrase`  查询（全文匹配）。                                          | 使用 `term` `terms` 查询（精确匹配）。                                             |
| **存储方式**           | 分词后存储（可能占用更多空间）。                                         | 原样存储（更节省空间）。                                                   |
| **是否支持聚合**       | 不支持（需启用 `fielddata`，但内存消耗高）。                             | 支持（默认启用 `doc_values`，高效聚合）。                                  |
| **是否支持排序**       | 不支持（分词后排序无意义）。                                             | 支持（按原始值排序）。                                                     |
| **典型场景**           | 日志内容、商品描述、文章正文。                                           | 用户 ID、状态码（如 "published"）、分类标签（如 "PHP"）。                   |

---

### **二、Text 类型详解**

#### **1. 核心原理**
- **分词处理**：  
  文本字段会被分词器（如 `standard`、`ik_max_word`）切分为多个词项（token），并进行过滤（如去停用词）、大小写转换等操作。
- **索引机制**：  
  分词后的词项用于构建倒排索引，支持全文搜索和模糊匹配。
- **自动映射**：  
  若未手动定义字段类型，Elasticsearch 会自动将字符串字段映射为 `text` 类型，并同时创建一个 `keyword` 子字段（如 `title.keyword`）。

#### **2. 适用场景**
- **全文搜索**：如商品描述、文章内容。
- **模糊匹配**：如搜索 "elasticsearch" 可匹配 "Elasticsearch" 或 "elastics"。
- **自动映射**：适合快速开发，但需注意分词可能带来的误匹配。

#### **3. PHP 示例**
```php
// 定义 text 字段（自动创建 keyword 子字段）
$mapping = [
    'mappings' => [
        'properties' => [
            'title' => ['type' => 'text']
        ]
    ]
];
$client->indices()->create(['index' => 'books', 'body' => $mapping]);

// 使用 match 查询（全文搜索）
$query = [
    'query' => [
        'match' => ['title' => 'Elasticsearch Guide']
    ]
];
```

---

### **三、Keyword 类型详解**

#### **1. 核心原理**
- **不分词**：  
  字段值原样存储，保留大小写、符号等原始属性。
- **索引机制**：  
  直接建立精确索引，支持等值查询、排序和高效聚合。
- **ignore_above 参数**：  
  默认值为 256，若字段值长度超过此限制，字段值将被忽略索引（数据仍存在，但无法被搜索到）。

#### **2. 适用场景**
- **精确匹配**：如用户 ID、状态码（如 "published"）。
- **聚合与排序**：如统计分类标签、按状态码排序。
- **避免分词干扰**：如枚举值、IP 地址、邮件地址。

#### **3. PHP 示例**
```php
// 定义 keyword 字段（精确匹配、聚合）
$mapping = [
    'mappings' => [
        'properties' => [
            'status' => [
                'type' => 'keyword',
                'ignore_above' => 100  // 超过 100 字符的字段值将被忽略索引
            ]
        ]
    ]
];
$client->indices()->create(['index' => 'orders', 'body' => $mapping]);

// 使用 term 查询（精确匹配）
$query = [
    'query' => [
        'term' => ['status' => 'paid']
    ]
];

// 使用 keyword 字段进行聚合
$agg = [
    'aggs' => [
        'status_count' => [
            'terms' => ['field' => 'status.keyword']
        ]
    ]
];
```

---

### **四、Text & Keyword 的组合使用**

#### **1. 同时支持全文搜索和精确匹配**
```php
// 定义 text 字段并添加 keyword 子字段
$mapping = [
    'mappings' => [
        'properties' => [
            'title' => [
                'type' => 'text',
                'fields' => [
                    'keyword' => ['type' => 'keyword']  // 精确匹配字段
                ]
            ]
        ]
    ]
];
$client->indices()->create(['index' => 'articles', 'body' => $mapping]);
```

#### **2. 查询示例**
- **全文搜索**（使用 `match`）：
  ```php
  $query_text = [
      'query' => [
          'match' => ['title' => 'Elasticsearch']
      ]
  ];
  ```
- **精确匹配**（使用 `term`）：
  ```php
  $query_keyword = [
      'query' => [
          'term' => ['title.keyword' => 'Elasticsearch: The Definitive Guide']
      ]
  ];
  ```

---

### **五、常见误区与注意事项**

1. **误用 `text` 进行精确匹配**：  
   - 若字段需精确匹配（如 `status`），应使用 `keyword`，否则 `match` 查询会因分词导致误匹配。

2. **忽略 `ignore_above` 参数**：  
   - 若字段值长度超过 `ignore_above`（默认 256），字段值将被忽略索引，但数据仍存在。需根据业务需求调整此参数。

3. **自动映射的潜在风险**：  
   - 自动映射会为 `text` 字段创建 `keyword` 子字段，但若手动定义字段类型，需显式添加 `keyword` 子字段。

4. **聚合性能优化**：  
   - 避免对 `text` 字段启用 `fielddata`，除非必须聚合，否则可能导致内存飙升。

---

### **六、总结**

| **类型**     | **适用场景**                         | **推荐查询方式**       | **是否支持聚合/排序** |
|--------------|--------------------------------------|------------------------|-----------------------|
| **text**     | 全文搜索、模糊匹配                   | `match`                | ❌（需启用 fielddata） |
| **keyword**  | 精确匹配、聚合、排序                 | `term`                 | ✅                    |
| **组合使用** | 同时支持全文搜索和精确匹配           | `match` + `term`       | ✅（通过 keyword 子字段） |

通过合理选择 `text` 和 `keyword` 类型，可兼顾搜索灵活性与查询性能，满足不同业务场景的需求。